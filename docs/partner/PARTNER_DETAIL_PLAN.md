# Partner Detail View – Plan

## Industry Standards (Affiliate/Partner Admin Dashboards)

Based on Partnerize, Affise, GoAffPro, and similar platforms:

1. **Partner profile** – Name, email, code, status, commission rates, join date, notes
2. **Performance metrics** – Referred leads count, total commission earned, pending, paid
3. **Referred leads** – Leads attributed to this partner (name, email, status, revenue, commission)
4. **Payment history** – Payouts with amount, status, date, notes
5. **Activity** – Clicks, conversions, status changes (optional)

## Our Implementation

### 1. API: GET /api/partners/[id]

Returns full partner detail. **Authentication & authorization:** Requires a valid JWT bearer token in the `Authorization` header (e.g., `Bearer <token>`). **Access rules:** (1) **Admin** role—can access any partner by id; (2) **Partner** role—can access only their own record. The partner user id field is exactly `supabase_user_id` on the Partner record. Authorization middleware for `GET /api/partners/[id]` must compare the JWT `sub` claim (string) to `partner.supabase_user_id` (string)—return 403 if they do not match for role `"partner"`; allow all ids for role `"admin"`. Implement tenant/self-access checks in authorization middleware before returning partner resource fields. **Error responses:** 401 for missing or invalid token; 403 for forbidden access (valid token but insufficient role or attempting to access another partner's data). **Rate limiting:** Enforce 100 requests/minute per caller identity—tracked by IP address and by JWT `sub` (token subject), whichever limit is hit first (i.e., both trackers apply; exceeding either triggers rate limit). Stricter burst limit: 200 requests over a 5-minute window. Document these limits in the API docs and apply them in the authorization/rate-limiting middleware for `GET /api/partners/[id]` that inspects JWT `role`/`sub` and enforces tenant/self-access checks before returning partner fields. **429 Too Many Requests:** Return 429 on rate-limit violations with standard headers: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `Retry-After` (seconds until reset). **Token scopes/claims:** Use `role` (admin | partner) and `sub` (user id) claims; ensure admin tokens have scope to read any partner, partner tokens only their own. Reference the endpoint path `GET /api/partners/[id]` and these rules when implementing authorization middleware.

- **Partner** – id, code, name, email, status, commissionOneTimePct, commissionRecurringPct, notes, registered_domains, path_prefixes, attribution_mode, createdAt, updatedAt. (`attribution_mode` is per-partner; `allow_ref_override` is a global system setting, not on Partner.)

**Validation rules for Partner fields:**
- **registered_domains** (string[]): Hostnames only—no protocol, ports, or paths. Disallow wildcards. Max 10 items; max 253 chars per item (RFC 1035). Allowed: lowercase letters, digits, hyphens; hostname must not start/end with hyphen. Trailing slashes are invalid and must be rejected. Validation failure: reject (do not sanitize).
- **path_prefixes** (string[]): Must start with `/`; no wildcards. Case-sensitive. Max 10 items; max 100 chars per item. Allowed: `/`, alphanumeric, hyphens, underscores; percent-encoded segments allowed. Trailing slashes: preserve as-is for matching (e.g., `/blog` and `/blog/` are distinct). Validation failure: reject (do not sanitize).
- **Stats** – referredLeadsCount, totalCommissionEarned, pendingCommission, totalPaidOut. These aggregates must not be computed in real time on every request (scalability risk). Store them in a fast cache (e.g., Redis) or a persisted aggregate table (e.g., materialized view or `partner_stats` table). **Invalidation/update strategies:** Incremental updates on lead/payout create/update/delete via DB triggers or application events, or an async background job that recomputes aggregates. All delta logic must exclude records where `deleted_at IS NOT NULL` (reference lead fields `deleted_at` and `partner_id`). On lead updates, detect `partner_id` changes and emit/execute atomic adjustments that **DECREMENT** the old partner's referredLeadsCount and commission totals and **INCREMENT** the new partner's metrics—use a DB transaction or an atomic update path in the event handler to avoid race conditions. **Delta behavior for partner soft-deletes:** Before applying any DECREMENT to the old partner's live aggregates, check the old partner's `deleted_at` flag. If `deleted_at IS NOT NULL`, skip decrementing the live partner aggregates (do not update referredLeadsCount, commission totals, or partner_stats for that partner); optionally route deltas to an archived stats store if historical accuracy is needed. The delta logic and event handler/DB trigger must perform this check before applying DECREMENTs. Live partner aggregates exclude soft-deleted partners; archived stats (if implemented) capture historical changes. Soft-delete toggles (`deleted_at` set/unset) are handled as equivalent to delete/create deltas. Partner_stats (or materialized view) refresh/reconciliation jobs must respect `deleted_at` and can fully recompute per-partner aggregates for correction. Refresh policies: on-change invalidation + TTL, or event-driven updates. Update referredLeadsCount and commission totals atomically to avoid drift.
- **Referred leads** – leads where partner_id = id (id, name, email, status, paidAt, oneTimeAmount, recurringAmount, commission). Paginated via `?page` and `?limit` query params. Paged response shape: `{ referredLeads: [...], pagination: { page, limit, total, totalPages } }`
- **Payouts** – partner_payouts for this partner (id, amount, status, paidAt, notes, leadIds). Paginated via `?page` and `?limit` query params. Paged response shape: `{ payouts: [...], pagination: { page, limit, total, totalPages } }`
- **Commission formula** – For each referred lead, `commission` = (partner.commissionOneTimePct / 100) × lead.oneTimeAmount + (partner.commissionRecurringPct / 100) × lead.recurringAmount (recurring_amount is monthly billing amount)
- **Error responses**: 404 partner not found, 401 Unauthorized, 403 Forbidden, 429 Too Many Requests (rate-limit violations), 500 Server error

### 2. Partner Detail Page: /dashboard/partners/[id]

- **Header** – Partner name, code badge, status, copy link, back to list
- **Profile card** – Email, commission rates (15% one-time, 10% recurring), join date, notes (editable)
- **Stats row** – 4 cards: Referred leads, Commission earned, Pending, Paid out
- **Referred leads table** – Name, email, status, revenue, commission, date
- **Payouts table** – Amount, status, date, notes
- **Actions** – Update status, update notes, record payout (deferred to future phase; show disabled "Record payout" button with tooltip "Coming Soon"). When implemented: required fields payout_date (ISO), amount (number), currency (default USD), recipient_id, method (e.g. bank_transfer), reference (optional); validation: amount > 0, payout_date valid; side effects: create Payout record, decrement partner balance, emit PayoutCreated event, audit log entry; success UX: confirmation modal; error UX: inline error messages; RBAC: admin or partner-admin role required

### 3. Navigation

- Partner rows in the partners table are clickable → navigate to /dashboard/partners/[id]
- Breadcrumb: Partners > [Partner Name]

### 4. Re-enable Partner Attribution

**Cookie spec:**
- Cookie name: `partner_ref`
- Payload: JSON `{ partner_id, referral_code[, incoming_ref_timestamp?] }`. The `incoming_ref_timestamp` is optional and may be null, undefined, or absent—it is stored only when needed for tie-breaking in **configurable** mode (see attribution logic); in `first_touch` and `last_touch` modes it is omitted. Conditional payload shape: for configurable mode include `incoming_ref_timestamp`; for other modes omit it. **Integrity protection:** Add a signature/mac field (e.g., `signature` or `hmac`) computed over the payload, or use a server-side encrypted/signed session cookie, so `partner_id` and `referral_code` cannot be tampered with. **Size limit:** Target ≤1KB (ideal ≤500 bytes). Enforce short key names and max lengths for `partner_id` and `referral_code`; prefer base64url or encodeURIComponent. If the signed/encrypted payload approaches 1KB, switch to server-side session storage with a small session ID cookie to avoid design issues.
- Expiration: 30 days
- Attributes: Secure, SameSite=Lax. Cookies should remain HttpOnly by default to protect against XSS. If client-side access is needed for form fields, use one of these safe alternatives: (1) read values server-side and inject into forms as hidden fields, (2) use a separate non-sensitive cookie explicitly marked for client-side access (e.g., a minimal flag or code-only cookie), or (3) rely on CSP and other XSS mitigations to safely read server-injected values.
- Set only after user consent (GDPR/CCPA). **Record opt-in before creating ref cookie:** Consent must be collected in a cookie banner, modal, or opt-in form. The exact event that must occur before creating the ref cookie is the explicit accept button handler (user clicks "Accept" or equivalent). Store consent in a consent record with fields: user_id or anonymous_id, timestamp, IP, consent_version; storage location: DB table `consents` or encrypted cookie. Withdrawal flow: provide an API/method to revoke consent (e.g., `revokeConsent(userId)`), which deletes the ref cookie, purges/flags associated personal data, and follows retention rules. For existing cookies belonging to non-consented users: scan and delete or refuse to read the ref cookie until opt-in; run a migration/cleanup job (e.g., `consent-cookie-cleanup` cron) to remove stale ref cookies.

**Attribution logic:**
- **Modes:** Two explicit modes plus one UI alias:
  - **first_touch** — once `partner_ref` cookie is set it is never overwritten (no timestamp needed).
  - **last_touch** — each referral always overwrites `partner_ref` (no tie-breaking needed).
  - **configurable** — UI alias for the global `allow_ref_override` setting: if `allow_ref_override=true` system-wide, treat as last_touch; if `false`, treat as first_touch. In configurable mode, the cookie stores `incoming_ref_timestamp` for tie-breaking.
- **Scope:** `attribution_mode` is a **per-partner** field on the Partner record. `allow_ref_override` is a **global** system setting (not per-partner); it is used only when `attribution_mode = "configurable"`. Precedence: **partner-level > global**—if a Partner has `attribution_mode = "first_touch"` or `"last_touch"`, that partner's mode wins; if `attribution_mode = "configurable"`, the global `allow_ref_override` applies.
- **Cross-partner conflict:** When a user hits multiple partners with different modes, use the **incoming referral's timestamp** (`incoming_ref_timestamp`) and the **effective mode for the incoming partner** to decide. Effective mode = Partner.mode if set to first_touch or last_touch; else global allow_ref_override (true → last_touch, false → first_touch). **Final decision logic:** (1) If effective mode is first_touch: first-write-wins—preserve existing `partner_ref` unless none exists. (2) If effective mode is last_touch: last-write-wins—always overwrite `partner_ref` with the incoming partner. When both partners use first_touch, the earlier `incoming_ref_timestamp` wins; when both use last_touch, the later wins. Deterministic: compare timestamps; ties use lexicographic partner_id.
- On first partner landing (`?ref=CODE`), set `partner_ref` according to the chosen mode.
- Expired or missing cookie → treat as direct traffic.
- Direct traffic after referral: (1) if partner cookie is still valid (within the 30-day window), direct returns should be attributed to the partner; (2) if the partner cookie has expired or been cleared, direct returns must not be attributed. Only unexpired partner cookies are honored for attribution.

**Contact form changes:**
- Add hidden fields `partner_id` and `referral_code` populated from the `partner_ref` cookie. **Default implementation: server-side injection.** On each request, the server reads the HttpOnly `partner_ref` cookie, decodes it, and injects hidden inputs `partner_id` and `referral_code` into the HTML form—keeping `partner_ref` HttpOnly and avoiding client-side access. **Alternatives (opt-in only):** (1) Use a separate minimal non-HttpOnly cookie (e.g., code-only) for client-side JS to read and populate the form—only if you need client-side access and accept the reduced XSS protection; (2) Remove HttpOnly from `partner_ref`—not recommended, as it exposes the cookie to XSS. Prefer server-rendered injection by default.
- Persist to Lead with `source="partner"`.

**Edge cases:**
- **Referrer fallback (enabled):** When no valid `partner_ref` cookie exists on first visit, use server-side referrer-based attribution. **(1) Partner schema:** Add explicit Partner fields `registered_domains: string[]` and `path_prefixes: string[]`—stored on the Partners table/entity and surfaced in partner management APIs (see Validation rules above). **(2) First-visit definition:** First-visit means "no `partner_ref` cookie present." Optional server-side reconciliation: check the most-recent attribution record for the user (session-cookie primary, DB lookup secondary). Document both approaches: cookie-only (simpler) and cookie + DB reconciliation (more robust for cross-device or cookie-cleared scenarios). **(3) Referer header parsing specification:** Parse the Referer header with a URL parser (e.g., `new URL(referer)`). Extract `hostname` and `pathname`; normalize hostname to lowercase; strip query string and fragments before path matching (query params and fragments are ignored for attribution). Percent-decode the pathname for comparison. Match hostname against `registered_domains` by exact equality; then check pathname `startsWith` any `path_prefixes` (case-sensitive). Log and reject malformed Referer headers that fail parsing. These rules apply when evaluating attribution_mode (first_touch vs last_touch). **(4) Referer validation and fraud controls:** Accept only exact-match or prefix-match against `registered_domains` and `path_prefixes` per the parsing spec above. Log and rate-limit suspicious referrers. Apply heuristics: high-volume single-referrer, invalid hostnames, mismatched user-agent. Mark referrer attribution as "best-effort" in metrics. **(5) Mode behavior:** Referrer fallback follows the partner's effective mode: if the matched partner has `attribution_mode = "first_touch"` or `"last_touch"`, use that; otherwise (when `attribution_mode = "configurable"`) use the global `allow_ref_override` (true → last_touch, false → first_touch). Precedence: partner-level > global. If effective mode is `last_touch`, referrer can overwrite existing attribution; if effective mode is `first_touch`, it only sets attribution when none exists. Match partner by `registered_domains`/`path_prefixes`, not by query params in the Referer header. If no cookie and no valid referrer match → do not attribute.
